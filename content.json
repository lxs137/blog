[{"title":"FineReport9.0插件加密破解","date":"2018-03-26T06:59:48.000Z","path":"2018/03/26/FineReport9-0插件加密破解/","text":"本文不讨论怎样进行破解，只是叙述一下研究加密过程的各个步骤 0.插件加密从FineReport9.0之后，所有的插件在打包过程中会被加密，如果直接解压打包后生成的jar包，仍然可以得到class文件，但是这些class文件是加密过的，无法用常见的Decompiler软件打开。 破解的思路有两种，一种是寻找FineReport加载插件所使用的ClassLoader，这其中必然有对Class文件解密的过程，还有一种就是寻找在插件打包的过程中，是怎样对插件进行加密的，本文采用的是第二种。 1.从Ant构建配置文件开始下面是构建文件(build.xml)的一部分，关键就在这部分： 1234&lt;taskdef name=\"pretreatment\" classname=\"com.fr.plugin.pack.PluginPretreatmentTask\"&gt; &lt;classpath refid=\"compile.classpath\"/&gt;&lt;/taskdef&gt;&lt;pretreatment baseDir=\"$&#123;basedir&#125;\"/&gt; 我们可以看到在使用Ant构建的过程中，使用了com.fr.plugin.pack.PluginPretreatmentTask这个类进行预处理，并传入了一个baseDir的参数，这个类位于fr-core这个jar包中 2.PluginPretreatmentTask 在PluginPretreatmentTask的execute函数中，关键是PluginStartup.start()(加载进特殊的ClassLoader)和PluginManager.pretreatment(this.config)(对插件编译后的Class二进制数据进行加密等其他操作), 3.加载ClassLoader 在PluginStartup.start()中关键是initEncryptedBridge函数，其中将bridge包中的Start类加载进来，并使用新的ClassLoader加载FinePluginBridge 12345private static void initEncryptedBridge() throws Exception &#123; EngineClassLoaderFactory var0 = (EngineClassLoaderFactory)Class.forName(\"com.fr.plugin.bridge.Start\").newInstance(); ClassLoader var1 = var0.create(); Class.forName(\"com.fr.plugin.bridge.FinePluginBridge\", true, var1);&#125; 在Start这个类中，主要做的事一是将bridge包中的一个classx文件加载进来，并对他进行AES的解密，解密后的数据就是EngineClassLoaderFactory“的一个子类，对其调用create方法 1234567891011121314151617181920212223public ClassLoader create() throws Exception &#123; return this.decryptFactory().create();&#125;private EngineClassLoaderFactory decryptFactory() throws Exception &#123; byte[] var1 = PluginBaseUtils.inputStream2Bytes(super.getResourceAsStream(\"com/fr/plugin/bridge/_4c1a49e2_0fcf_443f_94e3_f1c53998b507.classx\")); try &#123; Field var3 = Unsafe.class.getDeclaredField(\"theUnsafe\"); var3.setAccessible(true); Unsafe var2 = (Unsafe)var3.get((Object)null); byte[] var5 = this._e943abcb_2557_46ac_a860_56ba4460beec().doFinal(var1); Class var4 = var2.defineClass(\"com.fr.plugin.bridge._4c1a49e2_0fcf_443f_94e3_f1c53998b507\", var5, 0, var5.length, this, (ProtectionDomain)null); return (EngineClassLoaderFactory)var4.newInstance(); &#125; catch (Throwable var6) &#123; throw new ClassNotFoundException(\"\"); &#125;&#125;private Cipher _e943abcb_2557_46ac_a860_56ba4460beec() throws Exception &#123; Cipher var1 = Cipher.getInstance(\"AES\"); byte[] var2 = new byte[]&#123;38, 105, 13, 112, 95, -7, 73, -21, -122, 57, -75, 123, 31, -120, 84, 52&#125;; SecretKeySpec var4 = new SecretKeySpec(var2, \"AES\"); var1.init(2, var4); return var1;&#125; 如果将”_4c1a49e2_0fcf_443f_94e3_f1c53998b507.classx”文件解密并反编译，会发现生成一个与Start十分类似的类。因此，它就使用了这种方法将最终的ClassLoader使用不同的AES密钥加密了100层。这个ClassLoader的逻辑类似，同样是当类属于特定的包时，使用AES对其二进制数据进行解谜。 123456// 该ClassLoader只对下面这些包中的类起作用if (var1.startsWith(\"com.fr.plugin.engine\") || var1.startsWith(\"com.fr.plugin.A\") || var1.startsWith(\"com.fr.plugin.bridge\")) &#123; try &#123; return this.findClass(var1); &#125;&#125; 4.FinePluginBridge插件加密的关键代码如下： 123456789101112131415public void pretreatment(PluginPretreatmentConfig var1) throws Exception &#123; // 使用所有Pretreatment插件依次对源文件的class数据进行处理 com.fr.plugin.A.H.A.L().A(var1);&#125;static &#123; try &#123; // 加载插件加密关键类 A.B().A(); PluginManager.registerBridge(BRIDGE); &#125; catch (Throwable var1) &#123; com.fr.plugin.A.J.B.A(var1); &#125;&#125; 这里有一点有趣的就是，如果我们阅读com.fr.plugin.A.H.A.L().A(var1)里面的预处理过程会发现，它调用了一个com.fr.plugin.A.H.D的类，但这个类的class文件并没有出现在我们解压后的fr-core包中。他这里运用到了ClassLoader的缓存加载数据的特点，即会先寻找某个类是否已经loaded，在A.B().A()过程中就将这个com.fr.plugin.A.H.D类加载进内存 5.预加载关键类阅读A.B().A() 的代码发现，加载类的关键代码位于com.fr.plugin.A.M.A.B, E()的结果是类的数据, D()的结果是类的包名加类名: 12345678910private void A(ClassLoader classLoader) &#123; try &#123; // D(): getName -&gt; string // E(): getBytes -&gt; byte[] B.A(classLoader, D(), E()); // 相当于ClassLoader.defineClass(D(), E(), 0, E().length) &#125; catch (Throwable th) &#123; com.fr.plugin.A.J.B.A(th); &#125;&#125; 这段代码对每一个实现了相同接口的类调用了该过程将其加载进内存，每一个类的形式如下所示，其中的A方法就是将传入的两个字节数组拼接: 123456789101112@H(A = \"getName\")public String D() &#123; try &#123; return new String(new byte[]&#123;(byte) 99, (byte) 111, (byte) 109, (byte) 46, (byte) 102, (byte) 114, (byte) 46, (byte) 103, (byte) 101, (byte) 110, (byte) 101, (byte) 114, (byte) 97, (byte) 108, (byte) 46, (byte) 65, (byte) 112, (byte) 112, (byte) 67, (byte) 111, (byte) 110, (byte) 116, (byte) 101, (byte) 110, (byte) 116, (byte) 71, (byte) 101, (byte) 110, (byte) 101, (byte) 114, (byte) 97, (byte) 116, (byte) 111, (byte) 114&#125;, \"UTF-8\"); &#125; catch (Throwable th) &#123; return \"\"; &#125;&#125;@H(A = \"getBytes\")public byte[] E() &#123; return A(A(A(A(A(A(A(A(new byte[0], getByteCode0()), getByteCode1()), getByteCode2()), getByteCode3()), getByteCode4()), getByteCode5()), getByteCode6()), getByteCode7());&#125; 我们将这些类加载后，就会发现com.fr.plugin.A.H.D这个类了。 6.加密过程加密过程很简单，就是在打包过程中，使用随机生成的AES密钥对源码Class文件进行加密，并将密钥加密后存在打包过后的某个文件中。","tags":[{"name":"Java反编译","slug":"Java反编译","permalink":"http://www.menya.space/tags/Java反编译/"}]},{"title":"文章收藏","date":"2017-05-10T11:24:38.000Z","path":"2017/05/10/collection/","text":"用 Python 写一个 NoSQL 数据库 Microfacet材质和多层材质 图形学-知乎专栏 菲涅尔反射 让你的Python代码优雅又地道 GAN图像处理 Promise异步流程控制","tags":[{"name":"collection","slug":"collection","permalink":"http://www.menya.space/tags/collection/"}]}]